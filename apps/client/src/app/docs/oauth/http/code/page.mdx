import { Shield, AlertTriangle, ArrowRight } from 'lucide-react'

# 인증 코드 발급

<div className="border-l-4 border-yellow-500 bg-yellow-50 dark:bg-yellow-900/20 p-4 rounded my-6">
  <div className="flex items-start gap-3">
    <AlertTriangle className="h-5 w-5 text-yellow-600 dark:text-yellow-400 shrink-0 mt-0.5" />
    <div>
      <div className="font-semibold text-yellow-900 dark:text-yellow-100 mb-1">
        Deprecated
      </div>
      <div className="text-yellow-800 dark:text-yellow-200 text-sm">
        이 엔드포인트는 더 이상 권장되지 않습니다. 표준 OAuth 인증 흐름인
        <a href="/docs/oauth/http/authorize" className="underline font-medium mx-1">GET /v1/oauth/authorize</a>
        를 사용하세요. 기존 연동을 유지하는 경우에만 이 문서를 참고하세요.
      </div>
    </div>
  </div>
</div>

### 엔드포인트

```http
POST /v1/oauth/code
```

### 설명

사용자의 이메일과 비밀번호를 사용하여 인증한 후, Authorization Code를 발급받습니다.
이 코드는 일회성이며 **5분의 유효기간**을 가집니다.

Authorization Code는 이후 `/v1/oauth/token` 엔드포인트에서 Access Token으로 교환됩니다.

<div className="border-l-4 border-blue-500 bg-blue-50 dark:bg-blue-900/20 p-4 rounded my-6">
  <div className="flex items-start gap-3">
    <Shield className="h-5 w-5 text-blue-600 dark:text-blue-500 shrink-0 mt-0.5" />
    <div>
      <div className="font-semibold text-blue-900 dark:text-blue-100 mb-1">
        PKCE 파라미터 안내
      </div>
      <div className="text-blue-800 dark:text-blue-200 text-sm">
        <code className="mx-1 px-1.5 py-0.5 bg-blue-100 dark:bg-blue-800 rounded">code_challenge</code>와 <code className="mx-1 px-1.5 py-0.5 bg-blue-100 dark:bg-blue-800 rounded">code_challenge_method</code> 파라미터를 포함하시면 보안이 향상됩니다.
        PKCE를 사용하지 않는 방식도 지원됩니다.
        자세한 내용은 <a href="/docs/oauth/pkce" className="underline font-medium">PKCE 가이드</a>를 참고하세요.
      </div>
    </div>
  </div>
</div>

### 요청 파라미터

모든 파라미터는 JSON 형식으로 요청 본문(body)에 포함되어야 합니다.

| 파라미터                    | 타입       | 필수 여부 | 설명                                             | 예시                                            |
|-------------------------|----------|-------|------------------------------------------------|-----------------------------------------------|
| `email`                 | `String` | 필수    | 사용자의 DataGSM 이메일 주소                            | `student@gsm.hs.kr`                           |
| `password`              | `String` | 필수    | 사용자의 비밀번호                                      | `mypassword123`                               |
| `client_id`             | `String` | 필수    | DataGSM에서 발급받은 클라이언트 ID                        | `your-client-id`                              |
| `redirect_uri`          | `String` | 필수    | 인증 성공 후 리다이렉트될 URL (사전 등록 필요)                  | `https://your-app.com/callback`               |
| `code_challenge`        | `String` | 선택 (PKCE) | PKCE Code Verifier의 SHA-256 해시 (Base64URL 인코딩) | `E9Melhoa2OwvFrEMTJguCHaoeK1t8URWbuGJSstw-cM` |
| `code_challenge_method` | `String` | 선택 (PKCE) | Challenge 생성 방법 (항상 `S256` 사용)                    | `S256`                                        |

### 응답

#### 성공 응답 (200 OK)

```json
{
  "code": "abc123def456ghi789"
}
```

| 필드 | 타입 | 설명 |
| --- | --- | --- |
| `code` | `String` | Authorization Code (5분 유효, 일회성) |

### 오류 응답

| 상태 코드 | 설명 | 원인 |
| --- | --- | --- |
| `400 Bad Request` | 잘못된 요청 | 필수 파라미터 누락 또는 잘못된 형식 |
| `401 Unauthorized` | 인증 실패 | 이메일 또는 비밀번호가 올바르지 않음 |
| `404 Not Found` | 리소스를 찾을 수 없음 | 존재하지 않는 사용자 또는 등록되지 않은 클라이언트 |

### 요청 예시

#### cURL

```bash
curl -X POST "https://oauth.data.hellogsm.kr/v1/oauth/code" \
  -H "Content-Type: application/json" \
  -d '{
    "email": "student@gsm.hs.kr",
    "password": "mypassword123",
    "clientId": "your-client-id",
    "redirectUrl": "https://your-app.com/callback"
  }'
```

### 응답 예시

#### 성공

```json
{
  "code": "8f3a9b2c1d4e5f6789abcdef01234567"
}
```

#### 실패 (401 Unauthorized)

```json
{
  "error": "unauthorized",
  "error_description": "Invalid email or password"
}
```

#### 실패 (400 Bad Request)

```json
{
  "error": "invalid_request",
  "error_description": "Missing required parameter: email"
}
```

### PKCE 구현

PKCE는 Authorization Code 탈취를 방지하는 보안 메커니즘입니다. 다음 단계로 구현합니다.

#### 1. Code Verifier 생성

43-128자 길이의 랜덤 문자열을 생성합니다 (A-Z, a-z, 0-9, -, ., _, ~ 사용).

```javascript
function generateCodeVerifier() {
  const array = new Uint8Array(32); // 256 bits
  crypto.getRandomValues(array);
  return base64UrlEncode(array);
}

function base64UrlEncode(array) {
  const base64 = btoa(String.fromCharCode(...array));
  return base64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
}
```

#### 2. Code Challenge 생성

Code Verifier를 SHA-256으로 해싱하고 Base64URL 인코딩합니다.

```javascript
async function generateCodeChallenge(verifier) {
  const encoder = new TextEncoder();
  const data = encoder.encode(verifier);
  const hash = await crypto.subtle.digest('SHA-256', data);
  return base64UrlEncode(new Uint8Array(hash));
}
```

#### 3. Code Verifier 저장

생성한 `code_verifier`를 안전한 곳에 저장합니다 (Token 교환 시 사용).

```javascript
const codeVerifier = generateCodeVerifier();
const codeChallenge = await generateCodeChallenge(codeVerifier);

// sessionStorage에 저장 (브라우저)
sessionStorage.setItem('oauth_code_verifier', codeVerifier);
```

### 사용 예제

다음은 여러 언어에서 PKCE를 포함한 인증 코드 발급 예제입니다.

<CodeTabs>
  <CodeTab label="JavaScript" language="javascript" code={`// PKCE 유틸리티 함수
function base64UrlEncode(array) {
  const base64 = btoa(String.fromCharCode(...array));
  return base64.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=+$/, '');
}

function generateCodeVerifier() {
  const array = new Uint8Array(32);
  crypto.getRandomValues(array);
  return base64UrlEncode(array);
}

async function generateCodeChallenge(verifier) {
  const encoder = new TextEncoder();
  const data = encoder.encode(verifier);
  const hash = await crypto.subtle.digest('SHA-256', data);
  return base64UrlEncode(new Uint8Array(hash));
}

async function getAuthorizationCode(email, password, clientId, redirectUri) {
  try {
    // 1. PKCE Code Verifier 생성 및 저장
    const codeVerifier = generateCodeVerifier();
    const codeChallenge = await generateCodeChallenge(codeVerifier);
    sessionStorage.setItem('oauth_code_verifier', codeVerifier);

    // 2. Authorization Code 요청
    const response = await fetch('https://oauth.data.hellogsm.kr/v1/oauth/code', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        email,
        password,
        client_id: clientId,
        redirect_uri: redirectUri,
        code_challenge: codeChallenge,
        code_challenge_method: 'S256',
      }),
    });

    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.error_description || 'Failed to get authorization code');
    }

    const data = await response.json();
    return data.code;
  } catch (error) {
    console.error('Error:', error.message);
    throw error;
  }
}

// 사용 예시
const code = await getAuthorizationCode(
  'student@gsm.hs.kr',
  'mypassword123',
  'your-client-id',
  'https://your-app.com/callback'
);
console.log('Authorization Code:', code);
console.log('Code Verifier saved in sessionStorage');`} />

  <CodeTab label="Python" language="python" code={`import requests
import hashlib
import secrets
import base64

# PKCE Code Verifier 생성
def generate_code_verifier():
    code_verifier = base64.urlsafe_b64encode(secrets.token_bytes(32)).decode('utf-8')
    return code_verifier.rstrip('=')

# PKCE Code Challenge 생성
def generate_code_challenge(verifier):
    digest = hashlib.sha256(verifier.encode('utf-8')).digest()
    challenge = base64.urlsafe_b64encode(digest).decode('utf-8')
    return challenge.rstrip('=')

def get_authorization_code(email, password, client_id, redirect_uri):
    """
    DataGSM OAuth 인증 코드를 발급받습니다 (PKCE 포함).

    Args:
        email: 사용자 이메일
        password: 사용자 비밀번호
        client_id: 클라이언트 ID
        redirect_uri: 리다이렉트 URI

    Returns:
        tuple: (Authorization Code, Code Verifier)
    """
    try:
        # PKCE 생성
        code_verifier = generate_code_verifier()
        code_challenge = generate_code_challenge(code_verifier)

        response = requests.post(
            'https://oauth.data.hellogsm.kr/v1/oauth/code',
            headers={'Content-Type': 'application/json'},
            json={
                'email': email,
                'password': password,
                'client_id': client_id,
                'redirect_uri': redirect_uri,
                'code_challenge': code_challenge,
                'code_challenge_method': 'S256',
            }
        )
        response.raise_for_status()
        data = response.json()
        return data['code'], code_verifier
    except requests.exceptions.RequestException as e:
        print(f'Error: {e}')
        raise

# 사용 예시
code, verifier = get_authorization_code(
    'student@gsm.hs.kr',
    'mypassword123',
    'your-client-id',
    'https://your-app.com/callback'
)
print(f'Authorization Code: {code}')
print(f'Code Verifier: {verifier} (저장 필요)')`} />

  <CodeTab label="Java" language="java" code={`import java.net.http.*;
import java.net.URI;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.JsonNode;
import java.security.MessageDigest;
import java.security.SecureRandom;
import java.util.Base64;
import java.util.Map;

public class OAuthCodeService {
    private static final HttpClient client = HttpClient.newHttpClient();
    private static final ObjectMapper mapper = new ObjectMapper();

    // PKCE Code Verifier 생성
    public static String generateCodeVerifier() {
        SecureRandom random = new SecureRandom();
        byte[] bytes = new byte[32];
        random.nextBytes(bytes);
        return Base64.getUrlEncoder()
            .withoutPadding()
            .encodeToString(bytes);
    }

    // PKCE Code Challenge 생성
    public static String generateCodeChallenge(String verifier) throws Exception {
        MessageDigest digest = MessageDigest.getInstance("SHA-256");
        byte[] hash = digest.digest(verifier.getBytes("UTF-8"));
        return Base64.getUrlEncoder()
            .withoutPadding()
            .encodeToString(hash);
    }

    public static class CodeResult {
        public final String code;
        public final String verifier;

        public CodeResult(String code, String verifier) {
            this.code = code;
            this.verifier = verifier;
        }
    }

    public static CodeResult getAuthorizationCode(
        String email,
        String password,
        String clientId,
        String redirectUri
    ) throws Exception {
        // PKCE 생성
        String codeVerifier = generateCodeVerifier();
        String codeChallenge = generateCodeChallenge(codeVerifier);

        // 요청 본문 생성
        Map<String, String> requestBody = Map.of(
            "email", email,
            "password", password,
            "client_id", clientId,
            "redirect_uri", redirectUri,
            "code_challenge", codeChallenge,
            "code_challenge_method", "S256"
        );

        String requestBodyJson = mapper.writeValueAsString(requestBody);

        // HTTP 요청 생성
        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create("https://oauth.data.hellogsm.kr/v1/oauth/code"))
            .header("Content-Type", "application/json")
            .POST(HttpRequest.BodyPublishers.ofString(requestBodyJson))
            .build();

        // 요청 전송
        HttpResponse<String> response = client.send(
            request,
            HttpResponse.BodyHandlers.ofString()
        );

        // 응답 처리
        if (response.statusCode() != 200) {
            throw new RuntimeException("Failed to get authorization code: " + response.body());
        }

        JsonNode jsonNode = mapper.readTree(response.body());
        String code = jsonNode.get("code").asText();

        return new CodeResult(code, codeVerifier);
    }

    public static void main(String[] args) throws Exception {
        CodeResult result = getAuthorizationCode(
            "student@gsm.hs.kr",
            "mypassword123",
            "your-client-id",
            "https://your-app.com/callback"
        );
        System.out.println("Authorization Code: " + result.code);
        System.out.println("Code Verifier: " + result.verifier + " (저장 필요)");
    }
}`} />

  <CodeTab label="Kotlin" language="kotlin" code={`import java.net.http.HttpClient
import java.net.http.HttpRequest
import java.net.http.HttpResponse
import java.net.URI
import java.security.MessageDigest
import java.security.SecureRandom
import java.util.Base64
import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper
import com.fasterxml.jackson.module.kotlin.readValue

// PKCE 유틸리티
object PkceUtil {
    fun generateCodeVerifier(): String {
        val bytes = ByteArray(32)
        SecureRandom().nextBytes(bytes)
        return Base64.getUrlEncoder()
            .withoutPadding()
            .encodeToString(bytes)
    }

    fun generateCodeChallenge(verifier: String): String {
        val digest = MessageDigest.getInstance("SHA-256")
        val hash = digest.digest(verifier.toByteArray())
        return Base64.getUrlEncoder()
            .withoutPadding()
            .encodeToString(hash)
    }
}

data class CodeRequest(
    val email: String,
    val password: String,
    val client_id: String,
    val redirect_uri: String,
    val code_challenge: String,
    val code_challenge_method: String
)

data class CodeResponse(
    val code: String
)

data class CodeResult(
    val code: String,
    val verifier: String
)

class OAuthCodeService {
    private val client = HttpClient.newHttpClient()
    private val mapper = jacksonObjectMapper()

    fun getAuthorizationCode(
        email: String,
        password: String,
        clientId: String,
        redirectUri: String
    ): CodeResult {
        // PKCE 생성
        val codeVerifier = PkceUtil.generateCodeVerifier()
        val codeChallenge = PkceUtil.generateCodeChallenge(codeVerifier)

        val requestBody = CodeRequest(
            email = email,
            password = password,
            client_id = clientId,
            redirect_uri = redirectUri,
            code_challenge = codeChallenge,
            code_challenge_method = "S256"
        )
        val requestBodyJson = mapper.writeValueAsString(requestBody)

        val request = HttpRequest.newBuilder()
            .uri(URI.create("https://oauth.data.hellogsm.kr/v1/oauth/code"))
            .header("Content-Type", "application/json")
            .POST(HttpRequest.BodyPublishers.ofString(requestBodyJson))
            .build()

        val response = client.send(request, HttpResponse.BodyHandlers.ofString())

        if (response.statusCode() != 200) {
            throw RuntimeException("Failed to get authorization code: \${response.body()}")
        }

        val codeResponse: CodeResponse = mapper.readValue(response.body())
        return CodeResult(codeResponse.code, codeVerifier)
    }
}

// 사용 예시
fun main() {
    val service = OAuthCodeService()
    val result = service.getAuthorizationCode(
        email = "student@gsm.hs.kr",
        password = "mypassword123",
        clientId = "your-client-id",
        redirectUri = "https://your-app.com/callback"
    )
    println("Authorization Code: \${result.code}")
    println("Code Verifier: \${result.verifier} (저장 필요)")
}`} />
</CodeTabs>

### 보안 주의사항

#### 비밀번호 전송

- 이 엔드포인트는 사용자의 비밀번호를 전송하므로 **반드시 HTTPS**를 사용해야 합니다.
- HTTP를 사용하면 비밀번호가 평문으로 전송되어 중간자 공격에 취약합니다.

#### Code 유효기간

- Authorization Code는 **5분 후 자동으로 만료**됩니다.
- 만료된 Code는 사용할 수 없으므로, 발급 후 즉시 Token 교환을 수행하세요.

#### 일회성 사용

- Authorization Code는 **한 번만 사용**할 수 있습니다.
- 동일한 Code로 두 번째 Token 교환을 시도하면 실패합니다.

#### 리다이렉트 URI 검증

- `redirectUrl`은 DataGSM에 사전 등록된 URI와 정확히 일치해야 합니다.
- 등록되지 않은 URI를 사용하면 `403 Forbidden` 오류가 발생합니다.

### 다음 단계

Authorization Code를 발급받았다면, 다음 단계로 Token 교환을 진행하세요.

- [토큰 교환](/docs/oauth/http/token-exchange) - Authorization Code를 Access Token으로 교환
- [사용자 정보 조회](/docs/oauth/http/userinfo) - Access Token으로 사용자 정보 획득
