# 토큰 교환

### 엔드포인트

```http
POST /v1/oauth/token
```

### 설명

Authorization Code를 Access Token과 Refresh Token으로 교환합니다. 이 엔드포인트는 **반드시 서버에서만** 호출해야 하며, Client Secret이 필요합니다.

발급되는 토큰은 다음과 같은 용도로 사용됩니다:
- **Access Token**: 사용자 리소스 접근 (1시간 유효)
- **Refresh Token**: Access Token 갱신 (30일 유효)

이 엔드포인트는 `grant_type` 파라미터로 토큰 교환과 토큰 갱신을 모두 처리합니다. Authorization Code 교환 시에는 `grant_type`을 `authorization_code`로 설정하세요.

보안 강화를 위해 `code_verifier` 파라미터를 함께 전달하는 것을 권장합니다.

### 요청 파라미터

모든 파라미터는 JSON 형식으로 요청 본문(body)에 포함되어야 합니다.

| 파라미터 | 타입 | 필수 여부 | 설명 | 예시 |
| --- | --- | --- | --- | --- |
| `grant_type` | `String` | 필수 | 요청 타입 (`authorization_code` 고정) | `authorization_code` |
| `code` | `String` | 필수 | `/v1/oauth/code`에서 발급받은 Authorization Code | `abc123def456` |
| `client_id` | `String` | 필수 | DataGSM에서 발급받은 클라이언트 ID | `your-client-id` |
| `client_secret` | `String` | 필수 | DataGSM에서 발급받은 클라이언트 시크릿 (서버에서만 사용) | `your-client-secret` |
| `redirect_uri` | `String` | 필수 | Authorization Code 발급 시 사용한 리다이렉트 URI | `https://your-app.com/callback` |
| `code_verifier` | `String` | 권장 | PKCE Code Verifier (Authorization Code 발급 시 생성한 원본 값) | `dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk` |

### 응답

#### 성공 응답 (200 OK)

```json
{
  "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "token_type": "Bearer",
  "expires_in": 3600,
  "refresh_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
}
```

| 필드 | 타입 | 설명 |
| --- | --- | --- |
| `access_token` | `String` | JWT 형식의 Access Token (1시간 유효) |
| `token_type` | `String` | 토큰 타입 (`Bearer` 고정) |
| `expires_in` | `Int` | Access Token의 만료 시간 (초 단위, 3600 = 1시간) |
| `refresh_token` | `String` | Refresh Token (30일 유효) |

### 오류 응답

| 상태 코드 | 설명 | 원인 |
| --- | --- | --- |
| `400 Bad Request` | 잘못된 요청 | 필수 파라미터 누락 또는 잘못된 형식 |
| `401 Unauthorized` | 인증 실패 | Client Secret이 올바르지 않음 |
| `404 Not Found` | 리소스를 찾을 수 없음 | Authorization Code가 만료되었거나 존재하지 않음 |

### 요청 예시

#### cURL

```bash
curl -X POST "https://oauth.data.hellogsm.kr/v1/oauth/token" \
  -H "Content-Type: application/json" \
  -d '{
    "grant_type": "authorization_code",
    "code": "abc123def456",
    "client_id": "your-client-id",
    "client_secret": "your-client-secret",
    "redirect_uri": "https://your-app.com/callback",
    "code_verifier": "dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk"
  }'
```

### 응답 예시

#### 성공

```json
{
  "accessToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c",
  "refreshToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c",
  "expiresIn": 3600
}
```

#### 실패 (404 Not Found)

```json
{
  "error": "not_found",
  "error_description": "Authorization code not found or expired"
}
```

#### 실패 (401 Unauthorized)

```json
{
  "error": "unauthorized",
  "error_description": "Invalid client secret"
}
```

### 사용 예제

다음은 여러 언어에서 토큰을 교환하는 예제입니다.

<CodeTabs>
  <CodeTab label="JavaScript" language="javascript" code={`async function exchangeToken(code, codeVerifier, clientId, clientSecret, redirectUri) {
  try {
    const response = await fetch('https://oauth.data.hellogsm.kr/v1/oauth/token', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        grant_type: 'authorization_code',
        code,
        client_id: clientId,
        client_secret: clientSecret,
        redirect_uri: redirectUri,
        code_verifier: codeVerifier,
      }),
    });

    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.error_description || 'Failed to exchange token');
    }

    const data = await response.json();
    return {
      accessToken: data.accessToken,
      refreshToken: data.refreshToken,
      expiresIn: data.expiresIn,
    };
  } catch (error) {
    console.error('Error:', error.message);
    throw error;
  }
}

// 사용 예시
const codeVerifier = sessionStorage.getItem('oauth_code_verifier');
const tokens = await exchangeToken(
  'abc123def456',
  codeVerifier,
  'your-client-id',
  process.env.DATAGSM_CLIENT_SECRET,
  'https://your-app.com/callback'
);
console.log('Access Token:', tokens.accessToken);
console.log('Refresh Token:', tokens.refreshToken);
console.log('Expires In:', tokens.expiresIn, 'seconds');`} />

  <CodeTab label="Python" language="python" code={`import requests
import os

def exchange_token(code, code_verifier, client_id, client_secret, redirect_uri):
    """
    Authorization Code를 Access Token으로 교환합니다 (PKCE 포함).

    Args:
        code: Authorization Code
        code_verifier: PKCE Code Verifier
        client_id: 클라이언트 ID
        client_secret: 클라이언트 시크릿
        redirect_uri: 리다이렉트 URI

    Returns:
        dict: access_token, refresh_token, expires_in 포함
    """
    try:
        response = requests.post(
            'https://oauth.data.hellogsm.kr/v1/oauth/token',
            headers={'Content-Type': 'application/json'},
            json={
                'grant_type': 'authorization_code',
                'code': code,
                'client_id': client_id,
                'client_secret': client_secret,
                'redirect_uri': redirect_uri,
                'code_verifier': code_verifier,
            }
        )
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        print(f'Error: {e}')
        raise

# 사용 예시 (code/page.mdx에서 받은 verifier 사용)
tokens = exchange_token(
    code='abc123def456',
    code_verifier='dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk',
    client_id='your-client-id',
    client_secret=os.environ.get('DATAGSM_CLIENT_SECRET'),
    redirect_uri='https://your-app.com/callback'
)
print(f'Access Token: {tokens["access_token"]}')
print(f'Refresh Token: {tokens["refresh_token"]}')
print(f'Expires In: {tokens["expires_in"]} seconds')`} />

  <CodeTab label="Java" language="java" code={`import java.net.http.*;
import java.net.URI;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.JsonNode;
import java.util.Map;

public class OAuthTokenService {
    private static final HttpClient client = HttpClient.newHttpClient();
    private static final ObjectMapper mapper = new ObjectMapper();

    public static TokenResponse exchangeToken(
        String code,
        String codeVerifier,
        String clientId,
        String clientSecret,
        String redirectUri
    ) throws Exception {
        // 요청 본문 생성
        Map<String, String> requestBody = Map.of(
            "grant_type", "authorization_code",
            "code", code,
            "client_id", clientId,
            "client_secret", clientSecret,
            "redirect_uri", redirectUri,
            "code_verifier", codeVerifier
        );

        String requestBodyJson = mapper.writeValueAsString(requestBody);

        // HTTP 요청 생성
        HttpRequest request = HttpRequest.newBuilder()
            .uri(URI.create("https://oauth.data.hellogsm.kr/v1/oauth/token"))
            .header("Content-Type", "application/json")
            .POST(HttpRequest.BodyPublishers.ofString(requestBodyJson))
            .build();

        // 요청 전송
        HttpResponse<String> response = client.send(
            request,
            HttpResponse.BodyHandlers.ofString()
        );

        // 응답 처리
        if (response.statusCode() != 200) {
            throw new RuntimeException("Failed to exchange token: " + response.body());
        }

        JsonNode jsonNode = mapper.readTree(response.body());
        return new TokenResponse(
            jsonNode.get("access_token").asText(),
            jsonNode.get("refresh_token").asText(),
            jsonNode.get("expires_in").asInt()
        );
    }

    public static class TokenResponse {
        public final String accessToken;
        public final String refreshToken;
        public final int expiresIn;

        public TokenResponse(String accessToken, String refreshToken, int expiresIn) {
            this.accessToken = accessToken;
            this.refreshToken = refreshToken;
            this.expiresIn = expiresIn;
        }
    }

    public static void main(String[] args) throws Exception {
        String clientId = "your-client-id";
        String clientSecret = System.getenv("DATAGSM_CLIENT_SECRET");
        String codeVerifier = "dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk"; // code/page.mdx에서 저장한 값

        TokenResponse tokens = exchangeToken(
            "abc123def456",
            codeVerifier,
            clientId,
            clientSecret,
            "https://your-app.com/callback"
        );
        System.out.println("Access Token: " + tokens.accessToken);
        System.out.println("Refresh Token: " + tokens.refreshToken);
        System.out.println("Expires In: " + tokens.expiresIn + " seconds");
    }
}`} />

  <CodeTab label="Kotlin" language="kotlin" code={`import java.net.http.HttpClient
import java.net.http.HttpRequest
import java.net.http.HttpResponse
import java.net.URI
import com.fasterxml.jackson.annotation.JsonProperty
import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper
import com.fasterxml.jackson.module.kotlin.readValue

data class TokenRequest(
    val grant_type: String,
    val code: String,
    val client_id: String,
    val client_secret: String,
    val redirect_uri: String,
    val code_verifier: String
)

data class TokenResponse(
    @JsonProperty("access_token")
    val accessToken: String,
    @JsonProperty("refresh_token")
    val refreshToken: String,
    @JsonProperty("expires_in")
    val expiresIn: Int
)

class OAuthTokenService {
    private val client = HttpClient.newHttpClient()
    private val mapper = jacksonObjectMapper()

    fun exchangeToken(
        code: String,
        codeVerifier: String,
        clientId: String,
        clientSecret: String,
        redirectUri: String
    ): TokenResponse {
        val requestBody = TokenRequest(
            grant_type = "authorization_code",
            code = code,
            client_id = clientId,
            client_secret = clientSecret,
            redirect_uri = redirectUri,
            code_verifier = codeVerifier
        )
        val requestBodyJson = mapper.writeValueAsString(requestBody)

        val request = HttpRequest.newBuilder()
            .uri(URI.create("https://oauth.data.hellogsm.kr/v1/oauth/token"))
            .header("Content-Type", "application/json")
            .POST(HttpRequest.BodyPublishers.ofString(requestBodyJson))
            .build()

        val response = client.send(request, HttpResponse.BodyHandlers.ofString())

        if (response.statusCode() != 200) {
            throw RuntimeException("Failed to exchange token: \${response.body()}")
        }

        return mapper.readValue(response.body())
    }
}

// 사용 예시
fun main() {
    val service = OAuthTokenService()
    val clientId = "your-client-id"
    val clientSecret = System.getenv("DATAGSM_CLIENT_SECRET")
    val codeVerifier = "dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk" // code/page.mdx에서 저장한 값

    val tokens = service.exchangeToken(
        code = "abc123def456",
        codeVerifier = codeVerifier,
        clientId = clientId,
        clientSecret = clientSecret,
        redirectUri = "https://your-app.com/callback"
    )

    println("Access Token: \${tokens.accessToken}")
    println("Refresh Token: \${tokens.refreshToken}")
    println("Expires In: \${tokens.expiresIn} seconds")
}`} />
</CodeTabs>

### 보안 주의사항

#### Client Secret 보호

**가장 중요**: Client Secret은 **절대 클라이언트 측(브라우저, 모바일 앱)에 노출되어서는 안 됩니다.**

- ❌ **절대 금지**: 프론트엔드 코드에 하드코딩
- ❌ **절대 금지**: 브라우저의 localStorage, sessionStorage에 저장
- ❌ **절대 금지**: Git 저장소에 커밋
- ✅ **권장**: 서버의 환경 변수로 관리
- ✅ **권장**: 보안 볼트(AWS Secrets Manager, HashiCorp Vault 등) 사용

```bash
# 환경 변수 설정 예시
export DATAGSM_CLIENT_SECRET=your-client-secret

# .env 파일 (Git에 커밋 금지!)
DATAGSM_CLIENT_SECRET=your-client-secret
```

#### HTTPS 필수

- 이 엔드포인트는 Client Secret을 전송하므로 **반드시 HTTPS**를 사용해야 합니다.
- HTTP를 사용하면 Client Secret이 평문으로 전송되어 심각한 보안 위협이 됩니다.

#### 토큰 저장

- **Access Token**: sessionStorage 또는 메모리에 저장 (1시간 후 만료)
- **Refresh Token**: HttpOnly 쿠키 또는 서버 세션에 저장 (30일 후 만료)
- localStorage는 XSS 공격에 취약하므로 사용을 지양하세요.

### 다음 단계

Token 교환에 성공했다면, 다음 작업을 수행할 수 있습니다.

- [사용자 정보 조회](/docs/oauth/http/userinfo) - Access Token으로 사용자 정보 획득
- [토큰 갱신](/docs/oauth/http/tokens) - Refresh Token으로 새 Access Token 발급

실전 구현 예제가 필요하면 [Examples 문서](/docs/oauth/examples)를 참고하세요.
