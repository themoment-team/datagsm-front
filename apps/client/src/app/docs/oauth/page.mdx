# OAuth

### 개요

DataGSM OAuth는 OAuth 2.0 Authorization Code Grant 플로우를 기반으로 한 인증 시스템입니다.
이를 통해 사용자는 DataGSM 계정으로 서드파티 애플리케이션에 안전하게 로그인할 수 있으며,
애플리케이션은 사용자의 동의 하에 DataGSM의 사용자 정보에 접근할 수 있습니다.

OAuth 2.0은 업계 표준 인증 프로토콜로, 사용자 비밀번호를 직접 공유하지 않고도
안전하게 리소스에 대한 접근 권한을 부여할 수 있도록 설계되었습니다.

### 주요 특징

| 특징            | 설명                                                                      |
|---------------|-------------------------------------------------------------------------|
| **JWT 기반 토큰** | 모든 Access Token은 JWT(JSON Web Token) 형식으로 발급되어 서명 검증이 가능합니다.            |
| **Redis 캐싱**  | Redis를 활용하여 토큰 정보를 캐싱하고 빠른 검증을 제공합니다.                                   |
| **토큰 유효기간**   | Access Token 1시간, Refresh Token 30일, Authorization Code 5분의 유효기간을 가집니다. |
| **보안 강화**     | HTTPS 필수, Client Secret 기반 인증, State 파라미터를 통한 CSRF 방지를 지원합니다.           |
| **표준 준수**     | OAuth 2.0 RFC 6749 표준을 준수합니다.                                           |

### 시스템 요구사항

| 항목            | 요구사항                                      |
|---------------|-------------------------------------------|
| **프로토콜**      | HTTPS 필수 (개발 환경 제외)                       |
| **리다이렉트 URI** | 사전 등록된 리다이렉트 URI만 허용                      |
| **Client 등록** | DataGSM에서 Client ID 및 Client Secret 발급 필요 |

### 기본 개념

#### Authorization Code (인증 코드)

사용자가 로그인에 성공하면 발급되는 일회성 코드입니다. 이 코드는 Access Token으로 교환되며,
**5분의 유효기간**을 가집니다. 한 번 사용되면 무효화됩니다.

```
code=abc123def456
```

#### Access Token (접근 토큰)

사용자 리소스에 접근하기 위한 토큰입니다. JWT 형식으로 발급되며,
**1시간의 유효기간**을 가집니다. API 요청 시 `Authorization: Bearer` 헤더에 포함하여 사용합니다.

```
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

#### Refresh Token (갱신 토큰)

Access Token이 만료되었을 때 새로운 Access Token을 발급받기 위한 토큰입니다.
**30일의 유효기간**을 가지며, 안전한 곳에 보관해야 합니다.

#### Client ID & Client Secret

- **Client ID**: 애플리케이션을 식별하는 공개 식별자입니다. 프론트엔드에서 사용 가능합니다.
- **Client Secret**: 애플리케이션의 비밀 키입니다. **반드시 서버에서만 사용**해야 하며,
절대 프론트엔드 코드나 공개 저장소에 노출되어서는 안 됩니다.

### 인증 플로우

DataGSM OAuth의 Authorization Code Grant 플로우는 다음과 같이 동작합니다.

```mermaid
sequenceDiagram
    participant U as 사용자(브라우저)
    participant C as 클라이언트 애플리케이션
    participant O as DataGSM OAuth

    U->>C: 1. 로그인 버튼 클릭
    C->>O: 2. 인증 요청\n(clientId, redirectUri)
    O-->>U: 3. 로그인 페이지로 리다이렉트
    U->>O: 4. 이메일 / 비밀번호 입력
    O-->>U: 5. Authorization Code와 함께 리다이렉트
    U->>C: 6. Code를 애플리케이션에 전달
    C->>O: 7. Token 요청\n(code, clientSecret)
    O-->>C: 8. Access Token & Refresh Token 발급
    C->>O: 9. UserInfo 요청\n(Bearer Token)
    O-->>C: 10. 사용자 정보 응답
    C-->>U: 11. 로그인 완료
```

**플로우 설명**:

1. 사용자가 클라이언트 애플리케이션에서 "DataGSM 로그인" 버튼을 클릭합니다.
2. 클라이언트는 사용자를 DataGSM OAuth 서버의 인증 페이지로 리다이렉트합니다 (clientId, redirectUri 포함).
3. 사용자가 DataGSM 로그인 페이지에서 이메일과 비밀번호를 입력합니다.
4. 인증에 성공하면 DataGSM OAuth 서버는 Authorization Code를 발급합니다.
5. 사용자는 Authorization Code와 함께 클라이언트의 리다이렉트 URI로 돌아옵니다.
6. 클라이언트 서버는 Authorization Code를 받습니다.
7. 클라이언트 서버는 Authorization Code와 Client Secret을 사용하여 Token 교환을 요청합니다.
8. DataGSM OAuth 서버는 Access Token과 Refresh Token을 발급합니다.
9. 클라이언트 서버는 Access Token을 사용하여 사용자 정보를 요청합니다.
10. DataGSM OAuth 서버는 사용자 정보를 응답합니다.
11. 클라이언트 애플리케이션에서 로그인이 완료됩니다.

### 보안 가이드라인

OAuth 인증을 안전하게 구현하기 위해 다음 보안 가이드라인을 준수해야 합니다.

#### HTTPS 필수

모든 OAuth 통신은 **반드시 HTTPS**를 통해 이루어져야 합니다. HTTP를 사용하면
토큰이 중간에 탈취될 수 있습니다. 개발 환경에서는 예외적으로 localhost에서 HTTP를 허용할 수 있습니다.

#### Client Secret 관리

- **Client Secret은 절대 프론트엔드 코드에 포함하지 마세요.**
- 환경 변수나 보안 볼트에 안전하게 저장하세요.
- 공개 저장소(GitHub 등)에 커밋하지 마세요.
- 주기적으로 로테이션하는 것을 권장합니다.

```bash
# 환경 변수 예시
DATAGSM_CLIENT_SECRET=your-client-secret-here
```

#### State 파라미터 사용

CSRF(Cross-Site Request Forgery) 공격을 방지하기 위해 `state` 파라미터를 사용하세요.
State 파라미터는 클라이언트가 생성한 랜덤 문자열로, 요청 시 전송하고 콜백에서 검증합니다.

```javascript
// State 생성 예시
const state = crypto.randomBytes(16).toString('hex');
sessionStorage.setItem('oauth_state', state);

// 인증 요청 시 포함
const authUrl = `https://oauth.datagsm.com/login?clientId=${clientId}&state=${state}`;

// 콜백에서 검증
const returnedState = new URLSearchParams(window.location.search).get('state');
const savedState = sessionStorage.getItem('oauth_state');
if (returnedState !== savedState) {
  throw new Error('State mismatch - possible CSRF attack');
}
```

#### 토큰 저장

- **Access Token**: 메모리나 sessionStorage에 저장하는 것을 권장합니다.
- **Refresh Token**: 서버 측 세션이나 HttpOnly 쿠키에 저장하는 것을 권장합니다.
- localStorage는 XSS 공격에 취약하므로 민감한 토큰 저장에는 사용을 지양하세요.

#### 리다이렉트 URI 검증

- 리다이렉트 URI는 DataGSM에 사전 등록되어야 합니다.
- 와일드카드나 동적 리다이렉트 URI는 지원하지 않습니다.
- 정확히 일치하는 URI만 허용됩니다.

### 시작하기

DataGSM OAuth를 사용하는 방법은 세 가지가 있습니다. 프로젝트의 요구사항에 맞는 방법을 선택하세요.

#### 1. HTTP API 직접 사용

REST API를 직접 호출하여 OAuth 플로우를 구현합니다. 가장 유연하지만 구현 복잡도가 높습니다.

- [HTTP API 문서](/docs/oauth/http)
- [인증 코드 발급](/docs/oauth/http/code)
- [토큰 교환](/docs/oauth/http/token)
- [토큰 갱신](/docs/oauth/http/refresh)
- [사용자 정보 조회](/docs/oauth/http/userinfo)

#### 2. SDK 사용

공식 SDK를 사용하면 복잡한 OAuth 플로우를 간단하게 구현할 수 있습니다.

- [React SDK](/docs/oauth/sdk/react) - React 애플리케이션용
- [Java/Kotlin SDK](/docs/oauth/sdk/java) - Spring Boot 등 JVM 기반 애플리케이션용

#### 3. 실전 예제 참고

프레임워크별 완전한 구현 예제를 제공합니다. 시나리오에 맞는 예제를 선택하세요.

- [Next.js + Spring Boot](/docs/oauth/examples/nextjs-spring-boot) - 프론트에서 code까지, 서버에서 token 교환
- [React + Spring Boot (Kotlin)](/docs/oauth/examples/react-spring-boot-kotlin) - 프론트에서 token까지, 서버에 token 전달
- [Vanilla JS + NestJS](/docs/oauth/examples/vanilla-nestjs) - 세션 기반 인증 구현

### Base URL

DataGSM OAuth의 Base URL은 다음과 같습니다.

```
https://oauth.data.hellogsm.kr
```

```
https://oauth-userinfo.data.hellogsm.kr
```

### 다음 단계

- OAuth 플로우를 직접 구현하려면 [HTTP API 문서](/docs/oauth/http)를 참고하세요.
- SDK를 사용하려면 [SDK 문서](/docs/oauth/sdk)를 참고하세요.
- 실전 예제를 보려면 [Examples 문서](/docs/oauth/examples)를 참고하세요.

### 지원 및 문의

- **GitHub 이슈**: [DataGSM Front Issues](https://github.com/themoment-team/datagsm-front/issues)
- OAuth 인증 관련 문의는 GitHub Issues를 통해 제출해 주세요.
